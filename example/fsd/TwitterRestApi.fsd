// DO NOT EDIT: generated by fsdgenfsd

/// Twitter REST API
[info(version: 1.1)]
[http(url: "https://api.twitter.com/1.1")]
service TwitterRestApi
{
	[http(method: GET, path: "/statuses/mentions_timeline")]
	method getStatusesMentionsTimeline
	{
		/// Specifies the number of tweets to try and retrieve
		count: string;

		/// Returns result with an ID greater than the specified ID
		since_id: string;

		/// Returns results with an ID less than or equal to the specified ID
		max_id: string;

		/// When set to either true, t or 1, each tweet returned in a timeline will include a user object
		trim_user: string;

		/// This parameter enhances the contributors element of the status response
		contributor_details: string;

		/// The entities node will be disincluded when set to false
		include_entities: string;
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		ok: Tweets[];
	}

	[http(method: GET, path: "/statuses/user_timeline")]
	method getStatusesUserTimeline
	{
		/// Specifies the number of tweets to try and retrieve
		count: string;

		/// Returns result with an ID greater than the specified ID
		since_id: string;

		/// Returns results with an ID less than or equal to the specified ID
		max_id: string;

		/// When set to either true, t or 1, each tweet returned in a timeline will include a user object
		trim_user: string;

		/// This paramters will prevent from appearing in the returned timeline
		exclude_replies: boolean;

		/// This paramters enhances the contributors element of the status response to include the screen_name of the contributor
		contributor_details: boolean;

		/// When set to false, the timeline will strip any native retweet
		include_rts: boolean;
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		ok: Tweets[];
	}

	[http(method: GET, path: "/statuses/home_timeline")]
	method getStatusesHomeTimeline
	{
		/// Returns result with an ID greater than the specified ID
		since_id: string;

		/// Returns results with an ID less than or equal to the specified ID
		max_id: string;

		/// When set to either true, t or 1, each tweet returned in a timeline will include a user object
		trim_user: string;

		/// This paramters will prevent from appearing in the returned timeline
		exclude_replies: boolean;

		/// This paramters enhances the contributors element of the status response to include the screen_name of the contributor
		contributor_details: boolean;
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		ok: Tweets[];
	}

	[http(method: POST, path: "/statuses/retweets/{id}")]
	method postStatusesRetweetsId
	{
		/// The numerical ID of the desired status
		id: string;

		/// When set to either true, t or 1, each tweet returned in a timeline will include a user object
		[http(from: query)]
		trim_user: string;
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		tweets: Tweets;
	}

	[http(method: GET, path: "/statuses/show/{id}")]
	method getStatusesShowId
	{
		/// The numerical ID of the desired status
		id: string;

		/// When set to either true, t or 1, each tweet returned in a timeline will include a user object
		trim_user: string;

		/// When set to either true, t or 1, any Tweets returned that have been retweeted by the authenticating
		include_my_retweet: string;

		/// The entities node will be disincluded when set to false
		include_entities: string;
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		tweets: Tweets;
	}

	[http(method: POST, path: "/statuses/destroy/{id}")]
	method postStatusesDestroyId
	{
		/// The numerical ID of the desired status
		id: string;

		/// When set to either true, t or 1, each tweet returned in a timeline will include a user object
		[http(from: query)]
		trim_user: string;
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		tweets: Tweets;
	}

	[http(method: POST, path: "/statuses/update")]
	method postStatusesUpdate
	{
		/// The text of your status update
		[http(from: query)]
		status: string;

		/// The ID of an existing status
		[http(from: query)]
		in_reply_to_status_id: string;

		/// The latitude of the location
		[http(from: query)]
		lat: string;

		/// The longitude of the location
		[http(from: query)]
		long: string;

		/// A place in the world
		[http(from: query)]
		place_id: string;

		/// Whether or not to put a pin on the exact coordinates a tweet
		[http(from: query)]
		display_coordinates: string;

		/// When set to either true, t or 1, each tweet returned in a timeline will include a user object
		[http(from: query)]
		trim_user: string;
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		tweets: Tweets;
	}

	[http(method: GET, path: "/statuses/oembed")]
	method getStatusesOembed
	{
		/// The tweet/status id to return embed code for
		id: string;

		/// The encoded URL of the Tweet status to be embedded
		url: string;

		/// The maximum width in pixels that the embed should be rendered at
		maxwidth: string;

		/// Specifies whether the embedded tweet should automatically show the original message in the case that the embedded Tweet is a reply
		hide_media: string;

		/// Specifies whether the embedded Tweet html should include a 'script' element pointing to widgets.js
		hide_thread: string;

		/// Specifies whether the embedded Tweet should be left aligned
		align: string;

		/// A value for the TWT related parameters
		related: string;

		/// Languages code for the rendered embed
		lang: string;
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		tweets: Tweets;
	}

	[http(method: GET, path: "/lists/list")]
	method getListsList
	{
		/// The screen name of the user for whom to return results for
		screen_name: string;

		/// The ID of the user for whom to return results for
		user_id: string;
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		ok: Lists[];
	}

	[http(method: GET, path: "/lists/statuses")]
	method getListsStatuses
	{
		/// The numerical id of the list
		list_id: string;

		/// You can identify a list by its slug instead of its numerical id
		slug: string;

		/// The screen name of the user who owns the list being requested by a slug
		owner_screen_name: string;

		/// The user ID of the user who owns the list being requested by a slug
		owner_id: string;

		/// Returns results with an ID greater than the sepcified ID
		since_id: string;

		/// Returns results with an ID less than or equal to the specified ID
		max_id: string;

		/// Specifies the number of results to retrieve per page
		count: string;

		/// Entities are ON by default
		include_entities: string;

		/// When set to either true, t or 1, the list timeline will contain native retweets in addition to the standard stream of tweets
		include_rts: string;
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		ok: Tweets[];
	}

	[http(method: GET, path: "/lists/members/destroy", code: 200)]
	method getListsMembersDestroy
	{
		/// The numerical id of the list
		list_id: string;

		/// You can identify a list by its slug instrad of its numerical id
		slug: string;

		/// The screen name of the user who owns the list being requested by a slug
		owner_screen_name: string;

		/// The id of the user for whom to remove from the list
		user_id: string;

		/// The screen name of the user for whom to remove from the list
		screen_name: string;

		/// The is of the user who wons the list being requested by a slug
		owner_id: string;
	}:
	{
	}

	[http(method: GET, path: "/lists/memberships")]
	method getListsMemberships
	{
		/// The id of the user for whom to return results for
		user_id: string;

		/// The screen name of the user for whom to return results for
		screen_name: string;

		/// Breaks the results into pages
		cursor: string;

		/// When set to true, t or 1, will return just lists the authenticating user owns
		filter_to_owned_lists: string;
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		cursorLists: Cursor_lists;
	}

	[http(method: GET, path: "/lists/subscribers")]
	method getListsSubscribers
	{
		/// The numerical id of the list
		list_id: string;

		/// You can identify a list by its slug insted of its numerical id
		slug: string;

		/// the screen name of the user who owns the list being requested by a slug
		owner_screen_name: string;

		/// The user ID of the user who owns the list being requested by a slug
		owner_id: string;

		/// Breaks the results into pages
		cursor: string;

		/// Wehn set to either true, t or 1
		include_entities: string;

		/// When set to either true, t or 1
		skip_status: string;
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		cursorLists: Cursor_lists;
	}

	[http(method: POST, path: "/lists/subscribers/create")]
	method postListsSubscribersCreate
	{
		/// The numerical id of the list
		[http(from: query)]
		list_id: string;

		/// You can identify a list being requested by a slug
		[http(from: query)]
		slug: string;

		/// the screen name of the user who owns the list being requested by a slug
		[http(from: query)]
		owner_screen_name: string;

		/// The user ID of the user who owns the list being requested by a slug
		[http(from: query)]
		owner_id: string;
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		lists: Lists;
	}

	[http(method: GET, path: "/lists/subscribers/show")]
	method getListsSubscribersShow
	{
		/// The numerical id of the list
		list_id: string;

		/// You can identify a list being requested by a slug
		slug: string;

		/// The screen name of the user who owns the list being requested by a slug
		owner_screen_name: string;

		/// The id of the user for whom to remove from the list
		user_id: string;

		/// The screen name of the user for whom to remove from the list
		screen_name: string;

		/// The is of the user who wons the list being requested by a slug
		owner_id: string;

		/// Wehn set to either true, t or 1
		include_entities: string;

		/// When set to either true, t or 1
		skip_status: string;
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		users: Users;
	}

	[http(method: GET, path: "/lists/subscribers/destroy", code: 200)]
	method getListsSubscribersDestroy
	{
		/// The numerical id of the list
		list_id: string;

		/// You can identify a list being requested by a slug
		slug: string;

		/// the screen name of the user who owns the list being requested by a slug
		owner_screen_name: string;

		/// The user ID of the user who owns the list being requested by a slug
		owner_id: string;
	}:
	{
	}

	[http(method: GET, path: "/lists/members/create_all", code: 200)]
	method getListsMembersCreateAll
	{
		/// The numerical id of the list
		list_id: string;

		/// You can identify a list being requested by a slug
		slug: string;

		/// the screen name of the user who owns the list being requested by a slug
		owner_screen_name: string;

		/// The user ID of the user who owns the list being requested by a slug
		owner_id: string;

		/// The id of the user for whom to remove from the list
		user_id: string;

		/// The screen name of the user for whom to remove from the list
		screen_name: string;
	}:
	{
	}

	[http(method: GET, path: "/list/members/show")]
	method getListMembersShow
	{
		/// The numerical id of the list
		list_id: string;

		/// You can identify a list being requested by a slug
		slug: string;

		/// The id of the user for whom to remove from the list
		user_id: string;

		/// The screen name of the user for whom to remove from the list
		screen_name: string;

		/// The screen name of the user who owns the list being requested by a slug
		owner_screen_name: string;

		/// The user ID of the user who owns the list being requested by a slug
		owner_id: string;

		/// Wehn set to either true, t or 1
		include_entities: string;

		/// When set to either true, t or 1
		skip_status: string;
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		users: Users;
	}

	[http(method: GET, path: "/list/members")]
	method getListMembers
	{
		/// The numerical id of the list
		list_id: string;

		/// You can identify a list being requested by a slug
		slug: string;

		/// The screen name of the user who owns the list being requested by a slug
		owner_screen_name: string;

		/// The user ID of the user who owns the list being requested by a slug
		owner_id: string;

		/// Wehn set to either true, t or 1
		include_entities: string;

		/// When set to either true, t or 1
		skip_status: string;

		/// Breaks the results into pages
		cursor: string;
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		users: Users;
	}

	[http(method: POST, path: "/list/members/create", code: 200)]
	method postListMembersCreate
	{
		/// The numerical id of the list
		[http(from: query)]
		list_id: string;

		/// You can identify a list being requested by a slug
		[http(from: query)]
		slug: string;

		/// The screen name of the user for whom to remove from the list
		[http(from: query)]
		screen_name: string;

		/// The screen name of the user who owns the list being requested by a slug
		[http(from: query)]
		owner_screen_name: string;

		/// The user ID of the user who owns the list being requested by a slug
		[http(from: query)]
		owner_id: string;
	}:
	{
	}

	[http(method: POST, path: "/lists/destroy")]
	method postListsDestroy
	{
		/// The numerical id of the list
		[http(from: query)]
		list_id: string;

		/// You can identify a list being requested by a slug
		[http(from: query)]
		slug: string;

		/// The screen name of the user who owns the list being requested by a slug
		[http(from: query)]
		owner_screen_name: string;

		/// The user ID of the user who owns the list being requested by a slug
		[http(from: query)]
		owner_id: string;
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		lists: Lists;
	}

	[http(method: POST, path: "/lists/update", code: 200)]
	method postListsUpdate
	{
		/// The numerical id of the list
		[http(from: query)]
		list_id: string;

		/// You can identify a list being requested by a slug
		[http(from: query)]
		slug: string;

		/// The screen name of the user who owns the list being requested by a slug
		[http(from: query)]
		owner_screen_name: string;

		/// The user ID of the user who owns the list being requested by a slug
		[http(from: query)]
		owner_id: string;

		/// The name for the list
		[http(from: query)]
		name: string;

		/// Whether your list is public or private
		[http(from: query)]
		mode: string;

		/// The description to give the list
		[http(from: query)]
		description: string;
	}:
	{
	}

	[http(method: POST, path: "/lists/create")]
	method postListsCreate
	{
		/// The name for the list
		[http(from: query)]
		name: string;

		/// Whether your list is public or private
		[http(from: query)]
		mode: string;

		/// The description to give the list
		[http(from: query)]
		description: string;
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		lists: Lists;
	}

	[http(method: GET, path: "/lists/show")]
	method getListsShow
	{
		/// The numerical id of the list
		list_id: string;

		/// You can identify a list being requested by a slug
		slug: string;

		/// The screen name of the user who owns the list being requested by a slug
		owner_screen_name: string;

		/// The user ID of the user who owns the list being requested by a slug
		owner_id: string;
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		lists: Lists;
	}

	[http(method: GET, path: "/lists/subscriptions")]
	method getListsSubscriptions
	{
		/// The screen name of the user
		screen_name: string;

		/// The id of the user for whom to return results for
		user_id: string;

		/// The amount of results to return per page
		count: string;

		/// Breaks the results into pages
		cursor: string;
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		cursorLists: Cursor_lists;
	}

	[http(method: GET, path: "/list/members/destroy_all")]
	method getListMembersDestroyAll
	{
		/// The numerical id of the list
		list_id: string;

		/// You can identify a list being requested by a slug
		slug: string;

		/// The id of the user for whom to remove from the list
		user_id: string;

		/// The screen name of the user for whom to remove from the list
		screen_name: string;

		/// The screen name of the user who owns the list being requested by a slug
		owner_screen_name: string;

		/// The user ID of the user who owns the list being requested by a slug
		owner_id: string;
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		cursorLists: Cursor_lists;
	}

	[http(method: GET, path: "/direct_messages/sent")]
	method getDirectMessagesSent
	{
		since_id: string;

		max_id: string;

		count: string;

		page: string;

		include_entities: string;
	}:
	{
		/// OK
		[http(from: body, code: 200)]
		ok: Messages[];
	}

	[http(method: GET, path: "/direct_messages/show")]
	method getDirectMessagesShow
	{
		/// ID of direct message
		id: string;
	}:
	{
		/// OK
		[http(from: body, code: 200)]
		ok: Messages[];
	}

	[http(method: GET, path: "/search/tweets")]
	method getSearchTweets
	{
		/// URL-encoded search query of 500 characters max
		q: string;

		/// returns tweets by users located within given radius
		geocode: string;

		/// restricts tweets to a given language
		lang: string;

		/// language of query you are sending
		locale: string;

		/// specifies type of search results you prefer
		result_type: string;

		/// number of tweets to return
		count: string;

		/// returns tweets created before given date
		until: string;

		/// return results with ID greater than specified
		since_id: string;

		/// returns results with an ID less than/equal to specified ID
		max_id: string;

		/// whether or not to include entities
		include_entities: string;

		/// response will use the callback with given name
		callback: string;
	}:
	{
		/// OK
		[http(from: body, code: 200)]
		ok: Tweets[];
	}

	[http(method: GET, path: "/saved_searches/list")]
	method getSavedSearchesList
	{
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		ok: Query[];
	}

	[http(method: GET, path: "/saved_searches/show/{id}")]
	method getSavedSearchesShowId
	{
		/// The id of the saved search
		id: string;
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		query: Query;
	}

	[http(method: POST, path: "/saved_searches/create")]
	method postSavedSearchesCreate
	{
		/// The query of the search the user would like to save
		[http(from: query)]
		query: string;
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		query: Query;
	}

	[http(method: POST, path: "/saved_searches/destroy/{id}")]
	method postSavedSearchesDestroyId
	{
		/// The id of the saved search
		id: string;
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		query: Query;
	}

	[http(method: GET, path: "/direct_messages")]
	method getDirectMessages
	{
		/// return results with ID greater than specified
		since_id: string;

		/// returns results with an ID less than/equal to specified ID
		max_id: string;

		/// whether or not to include entities
		include_entities: string;

		/// whether or not to include status
		skip_status: string;
	}:
	{
		/// OK
		[http(from: body, code: 200)]
		ok: Messages[];
	}

	[http(method: POST, path: "/direct_messages/destroy")]
	method postDirectMessagesDestroy
	{
		/// ID of direct message to delete
		[http(from: query)]
		id: string;

		/// whether or not to include entities
		[http(from: query)]
		include_entities: string;
	}:
	{
		/// OK
		[http(from: body, code: 200)]
		messages: Messages;
	}

	[http(method: POST, path: "/direct_messages/new")]
	method postDirectMessagesNew
	{
		/// description
		[http(from: query)]
		user_id: string;

		/// screen name of user receiving message
		[http(from: query)]
		screen_name: string;

		/// text of your direct message
		[http(from: query)]
		text: string;
	}:
	{
		/// OK
		[http(from: body, code: 200)]
		messages: Messages;
	}

	[http(method: GET, path: "/friends/ids")]
	method getFriendsIds
	{
		/// ID of user for whom to return results for
		user_id: string;

		/// screen name of user for whom to return results for
		screen_name: string;

		/// causes list of connections to be broken in pages
		cursor: string;

		/// IDs converted to strings
		stringify_ids: string;

		/// number of IDs to attempt retrieval of
		count: string;
	}:
	{
		/// OK
		[http(from: body, code: 200)]
		cursorIds: Cursor_ids;
	}

	[http(method: GET, path: "/followers/ids")]
	method getFollowersIds
	{
		/// ID of user for whom to return results for
		user_id: string;

		/// screen name of user for whom to return results for
		screen_name: string;

		/// causes list of connections to be broken in pages
		cursor: string;

		/// IDs converted to strings
		stringify_ids: string;

		/// number of IDs to attempt retrieval of
		count: string;
	}:
	{
		/// OK
		[http(from: body, code: 200)]
		cursorIds: Cursor_ids;
	}

	[http(method: GET, path: "/friendships/incoming")]
	method getFriendshipsIncoming
	{
		/// causes list of connections to be broken in pages
		cursor: string;

		/// IDs converted to strings
		stringify_ids: string;
	}:
	{
		/// OK
		[http(from: body, code: 200)]
		cursorIds: Cursor_ids;
	}

	[http(method: GET, path: "/friendships/outgoing")]
	method getFriendshipsOutgoing
	{
		/// causes list of connections to be broken in pages
		cursor: string;

		/// IDs converted to strings
		stringify_ids: string;
	}:
	{
		/// OK
		[http(from: body, code: 200)]
		cursorIds: Cursor_ids;
	}

	[http(method: POST, path: "/friendships/create")]
	method postFriendshipsCreate
	{
		/// screen name of user for whom to befriend
		[http(from: query)]
		screen_name: string;

		/// ID of user for whom to befriend
		[http(from: query)]
		user_id: string;

		/// enable notifications for target user
		[http(from: query)]
		follow: string;
	}:
	{
		/// OK
		[http(from: body, code: 200)]
		users: Users;
	}

	[http(method: POST, path: "/friendships/destroy")]
	method postFriendshipsDestroy
	{
		/// screen name of user for whom to befriend
		[http(from: query)]
		screen_name: string;

		/// ID of user for whom to befriend
		[http(from: query)]
		user_id: string;
	}:
	{
		/// OK
		[http(from: body, code: 200)]
		users: Users;
	}

	[http(method: POST, path: "/friendships/update")]
	method postFriendshipsUpdate
	{
		/// screen name of user for whom to befriend
		[http(from: query)]
		screen_name: string;

		/// ID of user for whom to befriend
		[http(from: query)]
		user_id: string;

		/// enable/disable device notifications for user
		[http(from: query)]
		device: string;

		/// enable/disable retweets from target user
		[http(from: query)]
		retweets: string;
	}:
	{
		/// OK
		[http(from: body, code: 200)]
		friendship: Friendship;
	}

	[http(method: GET, path: "/friendships/show")]
	method getFriendshipsShow
	{
		/// user id of subject user
		source_id: string;

		/// screen_name of subject user
		source_screen_name: string;

		/// user id of target user
		target_id: string;

		/// screen name of target user
		target_screen_name: string;
	}:
	{
		/// OK
		[http(from: body, code: 200)]
		friendship: Friendship;
	}

	/// returns settings for user
	[http(method: GET, path: "/account/settings")]
	method getAccountSettings
	{
	}:
	{
		/// OK
		[http(from: body, code: 200)]
		settings: Settings;
	}

	/// updates user's settings
	[http(method: POST, path: "/account/settings")]
	method postAccountSettings
	{
		/// the Yahoo! Where On Earth ID to user as defaul tend location
		[http(from: query)]
		trend_location_woeid: string;

		/// enables/disables sleep time, silencing notifications
		[http(from: query)]
		sleep_time_enabled: string;

		/// the hour that sleep time should begin if enabled
		[http(from: query)]
		start_sleep_time: string;

		/// the hour that sleep time should end if enabled
		[http(from: query)]
		end_sleep_time: string;

		/// timezone dates and times should be displayed in
		[http(from: query)]
		time_zone: string;

		/// language which Twitter should render in for the user
		[http(from: query)]
		lang: string;
	}:
	{
		/// OK
		[http(from: body, code: 200)]
		settings: Settings;
	}

	/// sets which device Twitter delivers updates to for user
	[http(method: POST, path: "/account/update_delivery_device")]
	method postAccountUpdateDeliveryDevice
	{
		/// must be one of sms, none
		[http(from: query)]
		device: string;

		/// whether or not to include entities
		[http(from: query)]
		include_entities: string;
	}:
	{
		/// OK
		[http(from: body, code: 200)]
		settings: Settings;
	}

	/// sets values that users ar eable to set under Account tab
	[http(method: POST, path: "/account/update_profile")]
	method postAccountUpdateProfile
	{
		/// full name of profile
		[http(from: query)]
		name: string;

		/// url associated with profile
		[http(from: query)]
		url: string;

		/// city or country describing where user of account is.
		[http(from: query)]
		location: string;

		/// a description of user owning account
		[http(from: query)]
		description: string;

		/// whether or not to include entities
		[http(from: query)]
		include_entities: string;

		/// whether or not to include statuses in response
		[http(from: query)]
		skip_status: string;
	}:
	{
		/// OK
		[http(from: body, code: 200)]
		settings: Settings;
	}

	/// updates user's profile background image
	[http(method: POST, path: "/account/update_profile_background_image")]
	method postAccountUpdateProfileBackgroundImage
	{
		/// whether or not to tile background image
		[http(from: query)]
		tile: string;

		/// display background image or not
		[http(from: query)]
		use: string;

		/// whether or not to include entities
		[http(from: query)]
		include_entities: string;

		/// whether or not to include status in returned user objects
		[http(from: query)]
		skip_status: string;
	}:
	{
		/// OK
		[http(from: body, code: 200)]
		settings: Settings;
	}

	/// sets one or more hex values that controls color scheme
	[http(method: POST, path: "/account/update_profile_colors")]
	method postAccountUpdateProfileColors
	{
		/// profile background color
		[http(from: query)]
		profile_background_color: string;

		/// profile link color
		[http(from: query)]
		profile_link_color: string;

		/// profile sidebar's border color
		[http(from: query)]
		profile_sidebar_border_color: string;

		/// profile's sidebar background color
		[http(from: query)]
		profile_sidebar_fill_color: string;

		/// profile text color
		[http(from: query)]
		profile_text_color: string;

		/// whether or not to include entities
		[http(from: query)]
		include_entities: string;

		/// whether or not to include statuses
		[http(from: query)]
		skip_status: string;
	}:
	{
		/// OK
		[http(from: body, code: 200)]
		settings: Settings;
	}

	/// updates user's profile image
	[http(method: POST, path: "/account/update_profile_image")]
	method postAccountUpdateProfileImage
	{
		/// whether or not to include statuses
		[http(from: query)]
		skip_status: string;
	}:
	{
		/// OK
		[http(from: body, code: 200)]
		settings: Settings;
	}

	/// disallows retweets and device notifications from a user
	[http(method: GET, path: "/blocks/list")]
	method getBlocksList
	{
		/// whether or not to include entities
		include_entities: string;

		/// whether or not to include statuses in response
		skip_status: string;

		/// breaks block of user to be broken up into pages
		cursor: string;
	}:
	{
		/// OK
		[http(from: body, code: 200)]
		cursorUsers: Cursor_users;
	}

	/// returns array of numeric user ids of blocked users
	[http(method: GET, path: "/blocks/ids")]
	method getBlocksIds
	{
		/// returns array of numeric IDs as string IDs
		stringify_ids: string;

		/// breaks up block of user IDs into pages
		cursor: string;
	}:
	{
		/// OK
		[http(from: body, code: 200)]
		cursorUsers: Cursor_users;
	}

	/// blocks the specified user
	[http(method: POST, path: "/blocks/create")]
	method postBlocksCreate
	{
		/// screen name of user to be blocked
		[http(from: query)]
		screen_name: string;

		/// ID of user to be blocked
		[http(from: query)]
		user_id: string;

		/// whether or not to include entities
		[http(from: query)]
		include_entities: string;

		/// whether or not to skip statuses
		[http(from: query)]
		skip_status: string;
	}:
	{
		/// OK
		[http(from: body, code: 200)]
		users: Users;
	}

	/// un-blocks the specified user
	[http(method: POST, path: "/blocks/destroy")]
	method postBlocksDestroy
	{
		/// screen name of user to be un-blocked
		[http(from: query)]
		screen_name: string;

		/// ID of user to be un-blocked
		[http(from: query)]
		user_id: string;

		/// whether or not to include entities
		[http(from: query)]
		include_entities: string;

		/// whether or not to skip statuses
		[http(from: query)]
		skip_status: string;
	}:
	{
		/// OK
		[http(from: body, code: 200)]
		users: Users;
	}

	/// returns fully-hydrated user objects up to 100
	[http(method: GET, path: "/users/lookup")]
	method getUsersLookup
	{
		/// screen name of user to lookup
		screen_name: string;

		/// ID of user to lookup
		user_id: string;

		/// whether or not to include entities
		include_entities: string;
	}:
	{
		/// OK
		[http(from: body, code: 200)]
		ok: Users[];
	}

	/// returns a variety of info about specified user
	[http(method: GET, path: "/users/show")]
	method getUsersShow
	{
		/// screen name of user to be shown
		screen_name: string;

		/// ID of user to be shown
		user_id: string;

		/// whether or not to include entities
		include_entities: string;
	}:
	{
		/// OK
		[http(from: body, code: 200)]
		users: Users;
	}

	/// simple relevance-based user search
	[http(method: GET, path: "/users/search")]
	method getUsersSearch
	{
		/// the search query to run against people search
		q: string;

		/// specifies the page of results to receive
		page: string;

		/// number of people to return per page
		count: string;

		/// whether or not to include entities
		include_entities: string;
	}:
	{
		/// OK
		[http(from: body, code: 200)]
		ok: Users[];
	}

	/// collection of users specified user can contribute to
	[http(method: GET, path: "/users/contributees")]
	method getUsersContributees
	{
		/// screen name of user that is contributed to
		screen_name: string;

		/// ID of user to that is contributed to
		user_id: string;

		/// whether or not to include entities
		include_entities: string;

		/// whether or not to skip statuses
		skip_status: string;
	}:
	{
		/// OK
		[http(from: body, code: 200)]
		ok: Users[];
	}

	/// collection of users that can contribute to specified account
	[http(method: GET, path: "/users/contributors")]
	method getUsersContributors
	{
		/// screen name of user contributing
		screen_name: string;

		/// ID of user contributing
		user_id: string;

		/// whether or not to include entities
		include_entities: string;

		/// whether or not to skip statuses
		skip_status: string;
	}:
	{
		/// OK
		[http(from: body, code: 200)]
		ok: Users[];
	}

	[http(method: GET, path: "/geo/id/{place_id}")]
	method getGeoIdPlaceId
	{
		/// A place in the world
		place_id: string;
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		ok: Places[];
	}

	[http(method: GET, path: "/geo/reverse_geoncode")]
	method getGeoReverseGeoncode
	{
		/// The latitude to search around
		lat: string;

		/// The longtitude to search around
		long: string;

		/// A hint on region in which to search
		accuracy: string;

		/// This is the minimal granularity of place types to return
		granularity: string;

		/// A hint as to the number of results to return
		max_results: string;

		/// If supplied, the responses will use the JSON format with a callback of the given name
		callback: string;
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		ok: Places[];
	}

	[http(method: GET, path: "/geo/search")]
	method getGeoSearch
	{
		/// The latitude to search around
		lat: string;

		/// The longtitude to search around
		long: string;

		/// Free-form text to match against while executing a geo-based query
		query: string;

		/// An Ip address
		ip: string;

		/// A hint on region in which to search
		accuracy: string;

		/// This is the minimal granularity of place types to return
		granularity: string;

		/// This is the place_id which you would like to restrict the search results to
		contained_within: string;

		/// This parameter searches for places which have this givven street address
		[http(name: "attribute:street_address")]
		attributeStreetAddress: string;

		/// If supplied, the responses will use the JSON format with a callback of the given name
		callback: string;
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		ok: Places[];
	}

	[http(method: GET, path: "/geo/similar_places")]
	method getGeoSimilarPlaces
	{
		/// The latitude to search around
		lat: string;

		/// The longtitude to search around
		long: string;

		/// The name a place is known as
		name: string;

		/// This is the place_id which you would like to restrict the search results to
		contained_within: string;

		/// This parameter searches for places which have this givven street address
		[http(name: "attribute:street_address")]
		attributeStreetAddress: string;

		/// If supplied, the responses will use the JSON format with a callback of the given name
		callback: string;
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		ok: Places[];
	}

	[http(method: GET, path: "/geo/places")]
	method getGeoPlaces
	{
		/// The latitude to search around
		lat: string;

		/// The longtitude to search around
		long: string;

		/// The name a place is known as
		name: string;

		/// The token found in the response from geo/similar_places
		token: string;

		/// This is the place_id which you would like to restrict the search results to
		contained_within: string;

		/// This parameter searches for places which have this givven street address
		[http(name: "attribute:street_address")]
		attributeStreetAddress: string;

		/// If supplied, the responses will use the JSON format with a callback of the given name
		callback: string;
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		places: Places;
	}

	[http(method: GET, path: "/trends/place")]
	method getTrendsPlace
	{
		/// The yahoo where on earch id
		id: string;

		/// Setting this equal to hashtages will remove all hashtages from the trends list
		exclude: string;
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		trendInfo: TrendInfo;
	}

	[http(method: GET, path: "/trends/available")]
	method getTrendsAvailable
	{
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		ok: Location[];
	}

	[http(method: GET, path: "/trends/closest")]
	method getTrendsClosest
	{
		/// If provided with a long parameter the available trend locations wil be stored by distance
		lat: string;

		/// If provided with a lat parameters the available trend locations will be sorted by distance
		long: string;
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		ok: Location[];
	}

	[http(method: POST, path: "/users/report_spam")]
	method postUsersReportSpam
	{
		/// The ID or screen_name of the user you want to report as a spammer
		[http(from: query)]
		screen_name: string;

		/// The ID of the user you want to report as a spammer
		[http(from: query)]
		user_id: string;
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		users: Users;
	}

	[http(method: GET, path: "/help/configuration")]
	method getHelpConfiguration
	{
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		helpConfig: Help_Config;
	}

	[http(method: GET, path: "/help/languages")]
	method getHelpLanguages
	{
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		ok: Help_Language[];
	}

	[http(method: GET, path: "/help/privacy")]
	method getHelpPrivacy
	{
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		helpPrivacy: Help_Privacy;
	}

	[http(method: GET, path: "/help/tos")]
	method getHelpTos
	{
	}:
	{
		/// Success
		[http(from: body, code: 200)]
		helpTos: Help_Tos;
	}

	[http(method: GET, path: "/application/rate_limit_status", code: 200)]
	method getApplicationRateLimitStatus
	{
		/// A comma-separated list of resource families you want to know the current rate limit disposition for
		resources: string;
	}:
	{
	}

	data Tweets
	{
		contributors: Contributors[];

		coordinates: Coordinates;

		created_at: string;

		current_user_retweet: Tweets;

		entities: Entities;

		favorite_count: int32;

		favorited: boolean;

		filter_level: string;

		id: int32;

		id_str: string;

		in_reply_to_screen_name: string;

		in_reply_to_status_id: int32;

		in_reply_to_status_id_str: string;

		in_reply_to_user_id: int32;

		in_reply_to_user_id_str: string;

		lang: string;

		place: Places;

		possibly_sensitive: boolean;

		quoted_status_id: int32;

		quoted_status_id_str: string;

		quoted_status: Tweets;

		scopes: map<object>;

		retweet_count: int32;

		retweeted: boolean;

		retweeted_status: Tweets;

		source: string;

		text: string;

		truncated: string;

		user: Users;

		withheld_copyright: boolean;

		withheld_countries: string[];

		withheld_scope: string;
	}

	data Contributors
	{
		id: int32;

		id_str: string;

		screen_name: string;
	}

	data Coordinates
	{
		coordinates: double[];

		type: string;
	}

	data Users
	{
		contributors_enabled: boolean;

		created_at: string;

		default_profile: boolean;

		default_profile_image: boolean;

		description: string;

		entities: Entities;

		favorites_count: int32;

		follow_request_sent: boolean;

		following: boolean;

		followers_count: int32;

		friends_count: int32;

		geo_enabled: boolean;

		id: int32;

		id_str: string;

		is_translator: boolean;

		lang: string;

		listed_count: int32;

		location: string;

		name: string;

		notifications: boolean;

		profile_background_color: string;

		profile_background_image_url: string;

		profile_background_image_url_https: string;

		profile_background_tile: string;

		profile_banner_url: string;

		profile_image_url: string;

		profile_image_url_https: string;

		profile_link_color: string;

		profile_sidebar_border_color: string;

		profile_sidebar_fill_color: string;

		profile_text_color: string;

		profile_use_background_image: boolean;

		protected: boolean;

		screen_name: string;

		show_all_inline_media: boolean;

		status: Tweets;

		statuses_count: int32;

		time_zone: string;

		url: string;

		utc_offset: int32;

		verified: boolean;

		withheld_in_countries: string;

		withheld_scope: string;
	}

	data Entities
	{
		hashtags: Hashtags[];

		media: Media[];

		urls: URL[];

		user_mentions: User_Mention[];
	}

	data Hashtags
	{
		indices: int32[];

		text: string;
	}

	data Media
	{
		display_url: string;

		expanded_url: string;

		id: int32;

		id_str: string;

		indices: int32[];

		media_url: string;

		media_url_https: string;

		sizes: Sizes;

		source_status_id: int32;

		source_status_id_str: int32;

		type: string;

		url: string;
	}

	data Size
	{
		h: int32;

		resize: string;

		w: int32;
	}

	data Sizes
	{
		thumb: Size;

		large: Size;

		medium: Size;

		small: Size;
	}

	data URL
	{
		display_url: string;

		expanded_url: string;

		indices: string;

		url: string;
	}

	data User_Mention
	{
		id: int32;

		id_str: string;

		indices: int32[];

		name: string;

		screen_name: string;
	}

	data Places
	{
		attributes: map<object>;

		bounding_box: Bounding_box;

		country: string;

		country_code: string;

		full_name: string;

		id: string;

		name: string;

		place_type: string;

		url: string;
	}

	data Bounding_box
	{
		type: string;
	}

	data Lists
	{
		created_at: string;

		slug: string;

		name: string;

		description: string;

		mode: string;

		following: boolean;

		user: Users;

		member_count: int32;

		id_str: string;

		subscriber_count: int32;

		id: int32;

		uri: string;
	}

	data Cursor_lists
	{
		previous_cursor: int32;

		lists: Lists[];

		previous_cursor_str: string;

		next_cursor: int32;

		next_cursor_str: string;
	}

	data Cursor_users
	{
		previous_cursor: int32;

		users: Users[];

		previous_cursor_str: string;

		next_cursor: int32;

		next_cursor_str: string;
	}

	data Cursor_ids
	{
		previous_cursor: int32;

		users: int32[];

		previous_cursor_str: string;

		next_cursor: int32;

		next_cursor_str: string;
	}

	data Messages
	{
		created_at: string;

		entities: Entities;

		id: int32;

		id_string: string;

		recipient: Users;

		recipient_id: int32;

		recipient_screen_name: string;

		sender: Users;

		sender_id: int32;

		sender_screen_name: string;

		text: string;
	}

	data Query
	{
		created_at: string;

		id: int32;

		id_str: string;

		name: string;

		position: string;

		query: string;
	}

	data Friendship
	{
		relationship: Targets;

		source: Source;
	}

	data Targets
	{
		target: Target;
	}

	data Target
	{
		id_str: string;

		id: int32;

		followed_by: boolean;

		screen_name: string;

		following: boolean;
	}

	data Source
	{
		can_dm: boolean;

		blocking: boolean;

		id_str: boolean;

		all_replies: boolean;

		want_retweets: boolean;

		id: int32;

		marked_spam: boolean;

		followed_by: boolean;

		notifications_enable: boolean;

		screen_name: string;

		following: boolean;
	}

	data Settings
	{
		sleep_time: Sleep;

		use_cookie_personalization: boolean;

		trend_location: Location[];

		language: string;

		discoverable_by_email: boolean;

		always_use_https: boolean;

		protected: boolean;

		geo_enabled: boolean;

		show_all_inline_media: boolean;

		screen_name: string;
	}

	data Sleep
	{
		end_time: string;

		enabled: boolean;

		start_time: string;
	}

	data Location
	{
		name: string;

		placeType: PlaceType;

		woeid: int32;

		country: string;

		url: string;

		countryCode: string;

		parentid: int32;
	}

	data PlaceType
	{
		name: string;

		code: int32;
	}

	data TrendInfo
	{
		as_of: string;

		created_at: string;

		locations: Location[];

		trends: Trends[];
	}

	data Trends
	{
		events: string;

		name: string;

		promoted_content: string;

		query: string;

		url: string;
	}

	data Help_Config
	{
		dm_text_character_limit: int32;

		characters_reserved_per_media: int32;

		max_media_per_upload: int32;

		non_username_paths: string[];

		photo_size_limit: int32;

		photo_sizes: Sizes;
	}

	data Help_Language
	{
		code: string;

		status: string;

		name: string;
	}

	data Help_Privacy
	{
		privacy: string;
	}

	data Help_Tos
	{
		Tos: string;
	}
}

# getStatusesMentionsTimeline

Returns the 20 most recent mentions for the authenticating user

# getStatusesUserTimeline

Returns a collection of the most recent Tweets posted by the User

# getStatusesHomeTimeline

Returns a collection of the most recent Tweets

# postStatusesRetweetsId

Retweens a tweet

# getStatusesShowId

Retruns a single Tweet

# postStatusesDestroyId

Destroys the status specified by the required ID parameter

# postStatusesUpdate

Updates the authenticating user's status

# getStatusesOembed

Returns information allowing the creation of an embedded representation

# getListsList

Return all lists the authenticating or specified user subscribes to, including their own.

# getListsStatuses

Returns a timeline of tweets authored by memebers of the specified list

# getListsMembersDestroy

Returns the list of memebers destroy

# getListsMemberships

Returns the lists of the specified user has been added to

# getListsSubscribers

Returns the subscribers of the specified list

# postListsSubscribersCreate

Subscribes the authenticated user to the specified list

# getListsSubscribersShow

Check if the specified user is a subscriber of the specified list

# getListsSubscribersDestroy

Returns list of subscribers destroy

# getListsMembersCreateAll

Returns lists of members create_all

# getListMembersShow

Check if the specified user is a member of the specified list

# getListMembers

Returns the members of the specified list

# postListMembersCreate

Returns list of members create

# postListsDestroy

Returns list of destroy

# postListsUpdate

Returns lists of updates

# postListsCreate

Returns list of create

# getListsShow

Returns list of show

# getListsSubscriptions

Returns list of subscriptions

# getListMembersDestroyAll

Returns lists of destroy all

# getDirectMessagesSent

return 20 most recent direct messages sent

# getDirectMessagesShow

returns a single direct message specified by an id

# getSearchTweets

returns collection of relevant Tweets matching query

# getSavedSearchesList

Returns the authenticated user's saved search queries

# getSavedSearchesShowId

Retrieve the information for the saved search represented by the given id

# postSavedSearchesCreate

Create a new saved search for the authenticated user

# postSavedSearchesDestroyId

Destroy a saved search for the authenticating user

# getDirectMessages

return 20 most recent direct messages sent to user

# postDirectMessagesDestroy

destroys direct messages specified in required ID

# postDirectMessagesNew

sends a new direct message to specified user

# getFriendsIds

returns a cursored collection of user IDs followed by user

# getFollowersIds

returns a cursored collection of user IDs following the user

# getFriendshipsIncoming

returns collection of IDs of users with pending follow request

# getFriendshipsOutgoing

returns collection of IDs of users with pending follow request from the user

# postFriendshipsCreate

allows users to follow user sepcified by ID

# postFriendshipsDestroy

allows user to unfollow user psecified by ID

# postFriendshipsUpdate

Allows one to enable or disable settings for specified user

# getFriendshipsShow

returns detailed info about relationship between two users

# getAccountSettings

returns settings for user

# postAccountSettings

updates user's settings

# postAccountUpdateDeliveryDevice

sets which device Twitter delivers updates to for user

# postAccountUpdateProfile

sets values that users ar eable to set under Account tab

# postAccountUpdateProfileBackgroundImage

updates user's profile background image

# postAccountUpdateProfileColors

sets one or more hex values that controls color scheme

# postAccountUpdateProfileImage

updates user's profile image

# getBlocksList

disallows retweets and device notifications from a user

# getBlocksIds

returns array of numeric user ids of blocked users

# postBlocksCreate

blocks the specified user

# postBlocksDestroy

un-blocks the specified user

# getUsersLookup

returns fully-hydrated user objects up to 100

# getUsersShow

returns a variety of info about specified user

# getUsersSearch

simple relevance-based user search

# getUsersContributees

collection of users specified user can contribute to

# getUsersContributors

collection of users that can contribute to specified account

# getGeoIdPlaceId

Returns all the information about a know place

# getGeoReverseGeoncode

Given a latitude and a longitude, searches for up to 20 places that can be used as a place_id when updatting a status

# getGeoSearch

Search for places that can be attached to a statuses/updates

# getGeoSimilarPlaces

Locates places near the given coordinates which are similar in name

# getGeoPlaces

Create a new place object at the given latitude and logitude

# getTrendsPlace

Returns the top 10 trending topics for a specific WOEID

# getTrendsAvailable

Returns the availability

# getTrendsClosest

Returns the location that Twitter has trending topic information for

# postUsersReportSpam

Returna users report spam

# getHelpConfiguration

Returns the current configuration used by Twitter including twitter.com slugs which are not usernames

# getHelpLanguages

Returns the list of languages supported by Twitter along with the language code supported by Twitter

# getHelpPrivacy

Returns Twitter's privacy policy

# getHelpTos

Returns the Twitter Terms of Service

# getApplicationRateLimitStatus

Returns the current rate limits for methods belonging to the specified resource families
